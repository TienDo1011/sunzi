{"name":"Sunzi","tagline":"Sunzi: Server provisioning utility for minimalists","body":"Sunzi\r\n=====\r\n\r\n```\r\n\"The supreme art of war is to subdue the enemy without fighting.\" - Sunzi\r\n```\r\n\r\nSunzi is the easiest [server provisioning](http://en.wikipedia.org/wiki/Provisioning#Server_provisioning) utility designed for mere mortals. If Chef or Puppet is driving you nuts, try Sunzi!\r\n\r\nSunzi assumes that modern Linux distributions have (mostly) sane defaults and great package managers.\r\n\r\nIts design goals are:\r\n\r\n* **It's just shell script.** No clunky Ruby DSL involved. Most of the information about server configuration on the web is written in shell commands. Just copy-paste them, rather than translate it into an arbitrary DSL. Also, Bash is the greatest common denominator on minimum Linux installs.\r\n* **Focus on diff from default.** No big-bang overwriting. Append or replace the smallest possible piece of data in a config file. Loads of custom configurations make it difficult to understand what you are really doing.\r\n* **Always use the root user.** Think twice before blindly assuming you need a regular user - it doesn't add any security benefit for server provisioning, it just adds extra verbosity for nothing. However, it doesn't mean that you shouldn't create regular users with Sunzi - feel free to write your own recipes.\r\n* **Minimum dependencies.** No configuration server required. You don't even need a Ruby runtime on the remote server.\r\n\r\n### What's new:\r\n\r\n* v1.0: System functions are refactored into sunzi.mute() and sunzi.install().\r\n* v0.9: Support for [DigitalOcean](https://www.digitalocean.com) setup / teardown.\r\n* v0.8: Added `--sudo` option to `sunzi deploy`.\r\n* v0.7: Added `erase_remote_folder` and `cache_remote_recipes` preferences for customized behavior.\r\n* v0.6: System function sunzi::silencer() added for succinct log messages.\r\n* v0.5: Role-based configuration supported. Reworked directory structure. **Incompatible with previous versions**.\r\n\r\nQuickstart\r\n----------\r\n\r\nInstall:\r\n\r\n```bash\r\n$ [sudo] gem install sunzi\r\n```\r\n\r\nGo into your project directory (if it's a Rails project, `config` would be a good place to start with), then:\r\n\r\n```bash\r\n$ sunzi create\r\n```\r\n\r\nIt generates a `sunzi` folder along with subdirectories and templates. Inside `sunzi`, there are `sunzi.yml` and `install.sh`. Those two are the most important files that you mainly work on.\r\n\r\nGo into the `sunzi` directory, then run `sunzi deploy`:\r\n\r\n```bash\r\n$ cd sunzi\r\n$ sunzi deploy example.com\r\n```\r\n\r\nNow, what it actually does is:\r\n\r\n1. Compile `sunzi.yml` to generate attributes and retrieve remote recipes, then copy files into the `compiled` directory\r\n1. SSH to `example.com` and login as `root`\r\n1. Transfer the content of the `compiled` directory to the remote server and extract in `$HOME/sunzi`\r\n1. Run `install.sh` on the remote server\r\n\r\nAs you can see, all you need to do is edit `install.sh` and add some shell commands. That's it.\r\n\r\nA Sunzi project without any recipes or roles is totally fine, so that you can start small, go big as you get along.\r\n\r\nCommands\r\n--------\r\n\r\n```bash\r\n$ sunzi                                           # Show command help\r\n$ sunzi compile                                   # Compile Sunzi project\r\n$ sunzi create                                    # Create a new Sunzi project\r\n$ sunzi deploy [user@host:port] [role] [--sudo]   # Deploy Sunzi project\r\n\r\n$ sunzi setup [linode|digital_ocean]              # Setup a new VM on the cloud services\r\n$ sunzi teardown [linode|digital_ocean] [name]    # Teardown an existing VM on the cloud services\r\n```\r\n\r\nDirectory structure\r\n-------------------\r\n\r\nHere's the directory structure that `sunzi create` automatically generates:\r\n\r\n```bash\r\nsunzi/\r\n  install.sh      # main script\r\n  sunzi.yml       # add custom attributes and remote recipes here\r\n\r\n  recipes/        # put commonly used scripts here, referred from install.sh\r\n    sunzi.sh\r\n  roles/          # when role is specified, scripts here will be concatenated\r\n    app.sh        # to install.sh in the compile phase\r\n    db.sh\r\n    web.sh\r\n  compiled/       # everything under this folder will be transferred to the\r\n                  # remote server (do not edit directly)\r\n```\r\n\r\nHow do you pass dynamic values to a recipe?\r\n-------------------------------------------\r\n\r\nIn the compile phase, attributes defined in `sunzi.yml` are split into multiple files in `compiled/attributes`, one per attribute. We use filesystem as a sort of key-value storage so that it's easy to use from shell scripts.\r\n\r\nThe convention for argument passing to a recipe is to use `$1`, `$2`, etc. and put a comment line for each argument.\r\n\r\nFor instance, given a recipe `greeting.sh`:\r\n\r\n```bash\r\n# Greeting\r\n# $1: Name for goodbye\r\n# $2: Name for hello\r\n\r\necho \"Goodbye $1, Hello $2!\"\r\n```\r\n\r\nWith `sunzi.yml`:\r\n\r\n```yaml\r\nattributes:\r\n  goodbye: Chef\r\n  hello: Sunzi\r\n```\r\n\r\nThen, include the recipe in `install.sh`:\r\n\r\n```bash\r\nsource recipes/greeting.sh $(cat attributes/goodbye) $(cat attributes/hello)\r\n```\r\n\r\nNow, you get the following result. Isn't it awesome?\r\n\r\n```\r\nGoodbye Chef, Hello Sunzi!\r\n```\r\n\r\nRemote Recipes\r\n--------------\r\n\r\nRecipes can be retrieved remotely via HTTP. Put a URL in the recipes section of `sunzi.yml`, and Sunzi will automatically load the content and put it into the `compiled/recipes` folder in the compile phase.\r\n\r\nFor instance, if you have the following line in `sunzi.yml`,\r\n\r\n```yaml\r\nrecipes:\r\n  rvm: https://raw.github.com/kenn/sunzi-recipes/master/ruby/rvm.sh\r\n```\r\n\r\n`rvm.sh` will be available and you can refer to that recipe by `source recipes/rvm.sh`.\r\n\r\nYou may find sample recipes in this repository useful: https://github.com/kenn/sunzi-recipes\r\n\r\nRole-based configuration\r\n------------------------\r\n\r\nYou probably have different configurations between **web servers** and **database servers**.\r\n\r\nNo problem - how Sunzi handles role-based configuration is refreshingly simple.\r\n\r\nShell scripts under the `roles` directory, such as `web.sh` or `db.sh`, are automatically recognized as a role. The role script will be appended to `install.sh` at deploy, so you should put common configurations in `install.sh` and role specific procedures in the role script.\r\n\r\nFor instance, when you set up a new web server, deploy with a role name:\r\n\r\n```bash\r\nsunzi deploy example.com web\r\n```\r\n\r\nIt is equivalent to running `install.sh`, followed by `web.sh`.\r\n\r\nCloud Support\r\n-------------\r\n\r\nYou can setup a new VM, or teardown an existing VM interactively. Use `sunzi setup` and `sunzi teardown` for that.\r\n\r\nThe following screenshot says it all.\r\n\r\n![Sunzi for Linode](http://farm8.staticflickr.com/7210/6783789868_ab89010d5c.jpg)\r\n\r\nRight now, only [Linode](http://www.linode.com/) and [DigitalOcean](https://www.digitalocean.com) are supported.\r\n\r\nFor DNS, Linode and [Amazon Route 53](http://aws.amazon.com/route53/) are supported.\r\n\r\nVagrant\r\n-------\r\n\r\nIf you're using Sunzi with [Vagrant](http://vagrantup.com/), make sure that you have a root access via SSH.\r\n\r\nAn easy way is to edit `Vagrantfile`:\r\n\r\n```ruby\r\nVagrant::Config.run do |config|\r\n  config.vm.provision :shell do |shell|\r\n    shell.path = \"chpasswd.sh\"\r\n  end\r\nend\r\n```\r\n\r\nwith `chpasswd.sh`:\r\n\r\n```bash\r\n#!/bin/bash\r\n\r\nsudo echo 'root:vagrant' | /usr/sbin/chpasswd\r\n```\r\n\r\nand now run `vagrant up`, it will change the root password to `vagrant`.\r\n\r\nAlso keep in mind that you need to specify the port number 2222.\r\n\r\n```bash\r\n$ sunzi deploy localhost:2222\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}